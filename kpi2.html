<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KPI – FlowLab</title>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.3.0/dist/chart.umd.min.js"></script>

  <!-- jsPDF + autoTable (pour l'export PDF) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>

  <style>
    :root{
      --brand: #16a085;
      --muted:#6b7280;
      font-family: Inter, "Segoe UI", Roboto, Arial, sans-serif;
    }
    body{margin:0;background:#f4f6f8;color:#111;}
    header{background:linear-gradient(90deg,var(--brand),#138d75);color:#fff;padding:1rem 1.5rem}
    header h1{margin:0;font-size:1.25rem}
    .container{max-width:1200px;margin:1.25rem auto;padding:0 1rem}
    .kpi-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:1rem;margin-bottom:1rem}
    .kpi{background:#fff;padding:1rem;border-radius:12px;box-shadow:0 6px 18px rgba(2,6,23,0.06);display:flex;flex-direction:column;gap:.5rem}
    .kpi .label{color:var(--muted);font-weight:600;font-size:.9rem}
    .kpi .value{font-size:1.6rem;font-weight:800}
    .controls{display:flex;gap:.5rem;flex-wrap:wrap;align-items:center;margin-bottom:1rem}
    .controls select, .controls input[type="text"], .controls input[type="date"]{padding:.45rem .6rem;border-radius:8px;border:1px solid #ddd}
    .card{background:#fff;padding:1rem;border-radius:12px;box-shadow:0 6px 18px rgba(2,6,23,0.06);margin-bottom:1rem}
    #chart-wrap{height:420px}
    .table-actions{display:flex;gap:.5rem;flex-wrap:wrap;margin-bottom:.75rem}
    table{width:100%;border-collapse:collapse}
    th,td{padding:.55rem;border-bottom:1px solid #eee;text-align:left}
    thead th{background:var(--brand);color:#fff}
    .small-btn{padding:.35rem .6rem;border-radius:8px;border:0;background:#16a085;color:#fff;cursor:pointer}
    .small-btn.secondary{background:#2980b9}
    .muted{color:var(--muted)}
    @media (max-width:700px){ .kpi-grid{grid-template-columns:repeat(auto-fit,minmax(140px,1fr))} }
  </style>
</head>
<body>
  <header>
    <div class="container">
      <h1>FlowLab — KPIs Vaccination (National)</h1>
      <div class="muted">Source: <code>https://n8n-automation-server-waz-production.up.railway.app/webhook-test/kpi-national</code></div>
    </div>
  </header>

  <main class="container">
    <!-- KPI Tiles -->
    <section class="kpi-grid" id="kpi-tiles">
      <div class="kpi">
        <div class="label">Total prévues</div>
        <div class="value" id="kpi-prevues">—</div>
        <div class="muted" id="kpi-prevues-sub">somme des prévues</div>
      </div>
      <div class="kpi">
        <div class="label">Total administrées</div>
        <div class="value" id="kpi-admin">—</div>
        <div class="muted" id="kpi-admin-sub">somme des administrées</div>
      </div>
      <div class="kpi">
        <div class="label">Couverture moyenne (%)</div>
        <div class="value" id="kpi-coverage">—</div>
        <div class="muted" id="kpi-coverage-sub">moyenne pondérée</div>
      </div>
      <div class="kpi">
        <div class="label">myNewField (total)</div>
        <div class="value" id="kpi-myNewField">—</div>
        <div class="muted">somme myNewField</div>
      </div>
      <div class="kpi">
        <div class="label">Zero doses</div>
        <div class="value" id="kpi-zero_dose">—</div>
        <div class="muted">somme myNewField</div>
      </div>
    </section>

    <!-- Controls & chart -->
    <section class="card">
      <div class="controls">
        <label>
          Métrique :
          <select id="metric-select">
            <option value="prevues">Prévues (stack)</option>
            <option value="administrees">Administrées (stack)</option>
            <option value="coverage">Couverture moyenne (ligne)</option>
            <option value="zero_dose">Zero doses</option>
          </select>
        </label>

        <label>
          Filtrer province :
          <select id="province-filter">
            <option value="__all__">Toutes</option>
          </select>
        </label>

        <label>
          De :
          <input type="date" id="filter-from" />
        </label>

        <label>
          À :
          <input type="date" id="filter-to" />
        </label>

        <button class="small-btn" id="btn-apply">Appliquer filtres</button>
        <button class="small-btn secondary" id="btn-reset">Réinitialiser</button>
      </div>

      <div id="chart-wrap">
        <canvas id="kpi-chart" width="1200" height="420"></canvas>
      </div>
    </section>

    <!-- Table detailed -->
    <section class="card">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <h3 style="margin:0">Détail des enregistrements</h3>
        <div class="table-actions">
          <input type="text" id="table-search" placeholder="Rechercher..." />
          <button id="export-csv" class="small-btn">CSV</button>
          <button id="export-txt" class="small-btn secondary">TXT</button>
          <button id="export-pdf" class="small-btn" title="PDF">PDF</button>
        </div>
      </div>

      <div style="overflow:auto; margin-top:.75rem">
        <table id="kpi-table">
          <thead>
            <tr>
              <th>Province</th>
              <th>Date / Mois</th>
              <th>Prévues</th>
              <th>Administrées</th>
              <th>Couverture (%)</th>
              <th>myNewField</th>
              <th>Zero Doses</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>
  </main>

  <script>
  // ---------- Configuration ----------
  const SOURCE_URL = 'https://n8n-automation-server-waz-production.up.railway.app/webhook-test/kpi-national';
  // si fetch échoue, on utilisera fallbackData
  const fallbackData = [
    {
      province: "Kinshasa",
      prevues: 30,
      administrees: 2,
      couverture_pct: "6.7",
      myNewField: 1,
      // 'date' or 'month' may exist in real data — utilisé pour grouper par mois
      // date: "2024-11-12",
      zero_dose: 4
      
    },
    {
      province: "Kinshasa",
      prevues: 10,
      administrees: 5,
      couverture_pct: "50",
      myNewField: 0,
      date: "2024-12-05",
      zero_dose:2 
    },
    {
      province: "Bas-Congo",
      prevues: 20,
      administrees: 10,
      couverture_pct: "50",
      myNewField: 2,
      date: "2024-12-02",
      zero_dose: 4
    },
    {
      province: "Bas-Congo",
      prevues: 5,
      administrees: 3,
      couverture_pct: "2",
      myNewField: 2,
      date: "2024-12-05",
      zero_dose: 3
    },
    {
      province: "Bas-Congo",
      prevues: 20,
      administrees: 10,
      couverture_pct: "50",
      myNewField: 2,
      date: "2025-01-02",
      zero_dose: 5
    },
    {
      province: "Kinshasa",
      prevues: 105,
      administrees: 84,
      couverture_pct: "80",
      myNewField: 0,
      date: "2025-02-05",
      zero_dose: 7
    },
    {
      province: "Kinshasa",
      prevues: 33,
      administrees: 8,
      couverture_pct: "80",
      myNewField: 0,
      date: "2025-01-05",
      zero_dose: 5,
    },
    {
      province: "Bas-Congo",
      prevues: 25,
      administrees: 10,
      couverture_pct: "50",
      myNewField: 2,
      date: "2025-02-02",
      zero_dose: 6
    },
    {
      province: "Goma",
      prevues: 20,
      administrees: 10,
      couverture_pct: "50",
      myNewField: 2,
      date: "2025-01-02",
      zero_dose: 7
    },
    {
      province: "Goma",
      prevues: 15,
      administrees: 8,
      couverture_pct: "80",
      myNewField: 0,
      date: "2025-02-05",
      zero_dose: 3,
    },
    {
      province: "Goma",
      prevues: 15,
      administrees: 10,
      couverture_pct: "50",
      myNewField: 2,
      date: "2025-02-02",
      zero_dose: 5
    },
    {
      province: "Goma",
      prevues: 50,
      administrees: 10,
      couverture_pct: "50",
      myNewField: 2,
      date: "2024-12-05",
      zero_dose: 3
    },
  ];

  // ---------- Helpers ----------
  function safeNumber(v){ const n = Number(String(v).replace(',', '.')); return isNaN(n) ? 0 : n; }

  // normalize record: ensure fields exist and compute monthKey (YYYY-MM)
  function normalizeRecord(r){
    const obj = Object.assign({}, r);
    // Normalize keys (some apis might return strings)
    obj.province = obj.province ?? obj.province_name ?? obj.region ?? 'Inconnu';
    obj.prevues = safeNumber(obj.prevues ?? obj.prevue ?? obj.expected ?? 0);
    obj.administrees = safeNumber(obj.administrees ?? obj.administree ?? obj.admin ?? 0);
    // couverture pct might be string "6.7" or number
    obj.couverture_pct = safeNumber(obj.couverture_pct ?? obj.couverture ?? 0);
    obj.myNewField = safeNumber(obj.myNewField ?? 0);
    obj.zero_dose = safeNumber(obj.zero_dose ?? 0);

    // Determine date/month field if present
    const dateFields = ['date','date_rdv','date_administration','month','mois'];
    let parsedDate = null;
    for(const key of dateFields){
      if (obj[key]){
        // If month like "2024-11" or "Nov 2024" try parse
        const val = String(obj[key]).trim();
        // If it's already YYYY-MM or YYYY-MM-DD it will parse
        const d = new Date(val);
        if (!isNaN(d)){
          parsedDate = d;
          break;
        } else {
          // try to detect YYYY-MM
          const match = val.match(/(20\d{2})[-\/]?(\d{1,2})/);
          if (match){
            const d2 = new Date(Number(match[1]), Number(match[2]) - 1, 1);
            parsedDate = d2;
            break;
          }
        }
      }
    }
    // fallback: if no date available, set parsedDate = null
    obj._date = parsedDate; // may be null
    obj._monthKey = parsedDate ? `${parsedDate.getFullYear()}-${String(parsedDate.getMonth()+1).padStart(2,'0')}` : 'unknown';
    obj._displayDate = parsedDate ? parsedDate.toISOString().slice(0,10) : (obj.month || obj.mois || '—');
    return obj;
  }

  // Group by monthKey and province for chart
  function buildAggregates(data){
    // returns:
    // { months: [...sorted monthKeys], provinces: [...], matrix: {month: {province: {prevues, administrees, coverageSum, count}}} }
    const monthsSet = new Set();
    const provincesSet = new Set();
    const matrix = {};

    data.forEach(item => {
      const m = item._monthKey;
      const p = item.province;
      monthsSet.add(m);
      provincesSet.add(p);
      matrix[m] = matrix[m] || {};
      matrix[m][p] = matrix[m][p] || { prevues:0, administrees:0, coverageSum:0, count:0, zero_dose:0 };
      matrix[m][p].prevues += item.prevues;
      matrix[m][p].administrees += item.administrees;
      matrix[m][p].coverageSum += item.couverture_pct;
      matrix[m][p].zero_dose += item.zero_dose;
      matrix[m][p].count += 1;
    });

    const months = Array.from(monthsSet).sort();
    const provinces = Array.from(provincesSet).sort();

    return { months, provinces, matrix };
  }

  // utility: create color palette for N items (simple)
  function palette(n){
    const base = [
      '#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd',
      '#8c564b','#e377c2','#7f7f7f','#bcbd22','#17becf'
    ];
    const out = [];
    for(let i=0;i<n;i++) out.push(base[i % base.length]);
    return out;
  }

  // Read table content (headers + rows) for exports
  function readTableForExport(tableId){
    const table = document.getElementById(tableId);
    if (!table) return null;
    const headers = Array.from(table.querySelectorAll('thead th')).map(th => th.textContent.trim());
    const rows = Array.from(table.querySelectorAll('tbody tr')).map(tr => Array.from(tr.querySelectorAll('td')).map(td => td.textContent.trim()));
    return { headers, rows };
  }

  // Exports: CSV/TXT/PDF (reused approach)
  function exportCSV(tableId, filename='export.csv'){
    const data = readTableForExport(tableId);
    if (!data) return alert('Table introuvable');
    const lines = [];
    lines.push(data.headers.map(h => `"${h.replace(/"/g,'""')}"`).join(','));
    data.rows.forEach(r => lines.push(r.map(c => `"${c.replace(/"/g,'""')}"`).join(',')));
    const blob = new Blob([lines.join('\r\n')], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = filename; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  }

  function exportTXT(tableId, filename='export.txt'){
    const data = readTableForExport(tableId);
    if (!data) return alert('Table introuvable');
    const lines = [];
    lines.push(data.headers.join('\t'));
    data.rows.forEach(r => lines.push(r.join('\t')));
    const blob = new Blob([lines.join('\r\n')], { type: 'text/plain;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = filename; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  }

  async function exportPDF(tableId, filename='export.pdf'){
    const data = readTableForExport(tableId);
    if (!data) return alert('Table introuvable');
    // wait for jsPDF presence (simple)
    function waitJsPDF(ms=3000){
      return new Promise((res,rej)=>{
        const start = Date.now();
        (function check(){ if (window.jspdf && window.jspdf.jsPDF) return res(window.jspdf.jsPDF); if (Date.now()-start>ms) return rej(); setTimeout(check,100); })();
      });
    }
    let JsPDFClass = null;
    try{
      JsPDFClass = await waitJsPDF(3000);
    }catch(e){
      if (window.jsPDF) JsPDFClass = window.jsPDF;
    }
    if (!JsPDFClass && !(window.jsPDF)) {
      // fallback to text file download
      alert('jsPDF non disponible — export en TXT à la place.');
      return exportTXT(tableId, filename.replace('.pdf','.txt'));
    }
    const jsPDFCtor = JsPDFClass || window.jsPDF;
    const doc = new jsPDFCtor({ unit: 'pt', format: 'a4' });
    if (typeof doc.autoTable === 'function') {
      doc.setFontSize(12);
      doc.text('Export KPI - détail', 40, 40);
      doc.autoTable({ startY: 60, head: [data.headers], body: data.rows, styles:{fontSize:9}, headStyles:{fillColor:[22,160,133],textColor:255}, margin:{left:40,right:40} });
      doc.save(filename);
      return;
    }
    // fallback text render
    const margin = 40; let y = 40; const lh = 14;
    doc.setFontSize(10);
    doc.text(data.headers.join(' | '), margin, y); y += lh;
    for(const r of data.rows){
      if (y + lh > doc.internal.pageSize.height - 40) { doc.addPage(); y = 40; }
      doc.text(r.join(' | '), margin, y); y += lh;
    }
    doc.save(filename);
  }

  // ---------- Main rendering logic ----------
  let rawData = []; // normalized records
  let aggregates = null;
  let chartInstance = null;

  // populate province filter select
  function populateProvinceFilter(provinces){
    const sel = document.getElementById('province-filter');
    sel.innerHTML = '<option value="__all__">Toutes</option>' + provinces.map(p=>`<option value="${p}">${p}</option>`).join('');
  }

  // draw chart (metric: prevues/administrees/coverage)
  function drawChart(metric='prevues', provinceFilter='__all__'){
    if (!aggregates) return;
    const { months, provinces, matrix } = aggregates;
    // labels are months
    const labels = months.map(m => (m==='unknown' ? 'Inconnu' : m));
    // unique provinces list maybe filtered
    const provincesToUse = provinceFilter === '__all__' ? provinces : provinces.filter(p=>p===provinceFilter);

    const colors = palette(provincesToUse.length);

    // For metric prevues/administrees: create dataset per province
    const datasets = provincesToUse.map((p,i)=>{
      const data = labels.map(m => (matrix[m] && matrix[m][p] ? matrix[m][p][metric] : 0));
      return {
        label: p,
        data,
        backgroundColor: colors[i],
        stack: metric // all share same stack so they pile
      };
    });

    // If metric is coverage -> compute average coverage per month across provinces (weighted or simple average)
    let extraDatasets = [];
    if (metric === 'coverage') {
      const coverageLine = labels.map(m => {
        // compute weighted coverage by prevues if available
        let sumPrev = 0, sumCoverTimesPrev = 0;
        provinces.forEach(p => {
          const cell = matrix[m] && matrix[m][p];
          if (cell) {
            sumPrev += cell.prevues;
            sumCoverTimesPrev += (cell.coverageSum || 0) * (cell.prevues || 0);
          }
        });
        if (sumPrev > 0) return +(sumCoverTimesPrev / (sumPrev || 1)).toFixed(2);
        // fallback to simple mean
        let s=0,c=0;
        provinces.forEach(p=>{ const cell = matrix[m] && matrix[m][p]; if(cell){ s += (cell.coverageSum || 0); c += (cell.count||1);} });
        return c? +(s/c).toFixed(2) : 0;
      });

      extraDatasets.push({
        label: 'Couverture moyenne (%)',
        data: coverageLine,
        type: 'line',
        borderColor: '#111827',
        backgroundColor: '#111827',
        yAxisID: 'yCoverage',
        tension: 0.2,
        fill: false,
        pointRadius: 3
      });
    }

    // Destroy previous chart if exists
    if (chartInstance) { chartInstance.destroy(); chartInstance = null; }

    const ctx = document.getElementById('kpi-chart').getContext('2d');
    chartInstance = new Chart(ctx, {
      type: 'bar',
      data: { labels, datasets: datasets.concat(extraDatasets) },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: { mode: 'index', intersect: false },
        plugins: {
          tooltip: { mode: 'index', intersect: false },
          legend: { position: 'bottom' }
        },
        scales: {
          x: { stacked: metric !== 'coverage' },
          y: {
            stacked: metric !== 'coverage',
            title: { display: true, text: metric === 'prevues' ? 'Prévues' : (metric === 'administrees' ? 'Administrées' : 'Valeur') }
          },
          yCoverage: {
            display: metric === 'coverage',
            position: 'right',
            grid: { drawOnChartArea: false },
            title: { display: true, text: 'Couverture (%)' }
          }
        }
      }
    });
  }

  // render table rows (applies current filters)
  function renderTable(data){
    const tbody = document.querySelector('#kpi-table tbody');
    tbody.innerHTML = data.map(r => `<tr>
      <td>${r.province}</td>
      <td>${r._displayDate}</td>
      <td>${r.prevues}</td>
      <td>${r.administrees}</td>
      <td>${r.couverture_pct}</td>
      <td>${r.myNewField}</td>
      <td>${r.zero_dose}</td>
    </tr>`).join('');
  }

  // compute KPI tiles
  function computeKPIs(data){
    const totalPrevues = data.reduce((s,i)=>s + (i.prevues||0),0);
    const totalAdmin = data.reduce((s,i)=>s + (i.administrees||0),0);
    const totalZero = data.reduce((s,i)=>s + (i.zero_dose||0),0);
    // coverage weighted by prevues
    let covWeighted = 0;
    let sumPrev = 0;
    data.forEach(i => { covWeighted += (i.couverture_pct || 0) * (i.prevues || 0); sumPrev += (i.prevues || 0); });
    const coverageAvg = sumPrev ? +(covWeighted / sumPrev).toFixed(2) : +(data.reduce((s,i)=>s+(i.couverture_pct||0),0)/Math.max(1,data.length)).toFixed(2);
    const myNewSum = data.reduce((s,i)=>s + (i.myNewField||0),0);
    // update DOM
    document.getElementById('kpi-prevues').textContent = totalPrevues;
    document.getElementById('kpi-admin').textContent = totalAdmin;
    document.getElementById('kpi-coverage').textContent = coverageAvg + '%';
    document.getElementById('kpi-myNewField').textContent = myNewSum;
    document.getElementById('kpi-zero_dose').textContent = totalZero;
  }

  // Apply filters (province + date range)
  function applyFiltersAndRender(){
    const province = document.getElementById('province-filter').value;
    const fromV = document.getElementById('filter-from').value;
    const toV = document.getElementById('filter-to').value;
    const metric = document.getElementById('metric-select').value;

    const fromDate = fromV ? new Date(fromV) : null;
    const toDate = toV ? new Date(toV) : null;

    let filtered = rawData.slice();

    if (province && province !== '__all__'){
      filtered = filtered.filter(r => r.province === province);
    }
    if (fromDate){
      filtered = filtered.filter(r => r._date && r._date >= new Date(fromDate.getFullYear(), fromDate.getMonth(), fromDate.getDate(),0,0,0));
    }
    if (toDate){
      // include whole day
      const toDayEnd = new Date(toDate.getFullYear(), toDate.getMonth(), toDate.getDate(),23,59,59,999);
      filtered = filtered.filter(r => r._date && r._date <= toDayEnd);
    }

    // recompute aggregates from filtered set
    aggregates = buildAggregates(filtered);
    drawChart(metric, province);
    computeKPIs(filtered);
    renderTable(filtered);
  }

  // init page: fetch data, normalize & setup UI
  async function init(){
    let dataRaw = [];
    try {
      const resp = await fetch(SOURCE_URL);
      if (!resp.ok) throw new Error('HTTP ' + resp.status);
      const j = await resp.json();
      // j should be an array; if object, wrap
      dataRaw = Array.isArray(j) ? j : (j ? [j] : []);
      if (dataRaw.length === 0) throw new Error('empty');
    } catch (err) {
      console.warn('Fetch KPI failed, using fallbackData. Error:', err);
      dataRaw = fallbackData;
    }

    // Normalize
    rawData = dataRaw.map(normalizeRecord);

    // Build global aggregates & province list
    const ag = buildAggregates(rawData);
    aggregates = ag;
    populateProvinceFilter(ag.provinces);

    // set default date inputs to range of data if available
    const allDates = rawData.map(d=>d._date).filter(Boolean).sort((a,b)=>a-b);
    if (allDates.length){
      const min = allDates[0], max = allDates[allDates.length-1];
      document.getElementById('filter-from').value = min.toISOString().slice(0,10);
      document.getElementById('filter-to').value = max.toISOString().slice(0,10);
    } else {
      // default: blank
    }

    // initial render: metric prevues, all provinces
    computeKPIs(rawData);
    drawChart(document.getElementById('metric-select').value, '__all__');
    renderTable(rawData);

    // Bind controls
    document.getElementById('btn-apply').addEventListener('click', applyFiltersAndRender);
    document.getElementById('btn-reset').addEventListener('click', () => {
      document.getElementById('province-filter').value = '__all__';
      document.getElementById('filter-from').value = '';
      document.getElementById('filter-to').value = '';
      document.getElementById('metric-select').value = 'prevues';
      applyFiltersAndRender();
    });
    document.getElementById('metric-select').addEventListener('change', ()=> applyFiltersAndRender());
    document.getElementById('province-filter').addEventListener('change', ()=> applyFiltersAndRender());

    // search realtime
    document.getElementById('table-search').addEventListener('input', (e) => {
      const q = e.target.value.toLowerCase();
      const trs = document.querySelectorAll('#kpi-table tbody tr');
      trs.forEach(tr => {
        const txt = tr.textContent.toLowerCase();
        tr.style.display = txt.includes(q) ? '' : 'none';
      });
    });

    // exports
    document.getElementById('export-csv').addEventListener('click', ()=> exportCSV('kpi-table','kpi_export.csv'));
    document.getElementById('export-txt').addEventListener('click', ()=> exportTXT('kpi-table','kpi_export.txt'));
    document.getElementById('export-pdf').addEventListener('click', ()=> exportPDF('kpi-table','kpi_export.pdf'));
  }

  // Run init on load
  window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
